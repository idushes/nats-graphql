"""
NATS JetStream Key-Value store information.
Represents metadata about a KV bucket including its configuration and current state.
"""
type KeyValue {
  "Name of the KV bucket"
  bucket: String!

  "Maximum number of history entries per key (how many past values are retained)"
  history: Int!

  "Time-to-live for keys in seconds. 0 means keys do not expire"
  ttl: Int!

  "Storage backend type (e.g. JetStream)"
  storage: String!

  "Total size of the KV store in bytes"
  bytes: Int!

  "Total number of key-value pairs in the store"
  values: Int!

  "Whether the KV store data is compressed"
  isCompressed: Boolean!
}

"""
NATS JetStream stream information.
Represents metadata about a stream including its configuration and current runtime state.
"""
type StreamInfo {
  "Unique name of the stream"
  name: String!

  "List of subject filters the stream is listening on (e.g. ['orders.>', 'payments.*'])"
  subjects: [String!]!

  "Message retention policy: Limits (by count/size/age), Interest (while consumers exist), or WorkQueue (ack-based removal)"
  retention: String!

  "Maximum number of consumers allowed on this stream. -1 means unlimited"
  maxConsumers: Int!

  "Maximum number of messages stored in the stream. -1 means unlimited"
  maxMsgs: Int!

  "Maximum total size of messages in the stream in bytes. -1 means unlimited"
  maxBytes: Int!

  "Maximum age of messages in the stream in seconds. 0 means no age limit"
  maxAge: Int!

  "Storage type: File (persistent to disk) or Memory (in-memory only)"
  storage: String!

  "Number of stream replicas for high availability in a NATS cluster"
  replicas: Int!

  "Current number of messages stored in the stream"
  messages: Int!

  "Current total size of all messages in the stream in bytes"
  bytes: Int!

  "Current number of active consumers subscribed to this stream"
  consumers: Int!

  "Stream creation timestamp in RFC3339 format"
  created: String!

  "List of source streams this stream is aggregating from. Null if not sourcing"
  sources: [StreamSourceInfo!]
}

"""
Information about an upstream source stream.
"""
type StreamSourceInfo {
  "Name of the source stream"
  name: String!

  "Number of messages behind the source stream"
  lag: Int!

  "Duration since last activity in nanoseconds. -1 means no activity"
  active: Int!

  "Subject filter applied to this source, if any"
  filterSubject: String
}

"""
Single key-value entry from a KV bucket.
"""
type KVEntry {
  "Key name"
  key: String!

  "Value stored under this key (as UTF-8 string)"
  value: String!

  "Revision number (monotonically increasing version)"
  revision: Int!

  "Timestamp when this revision was created, in RFC3339 format"
  created: String!
}

"""
Single message from a NATS JetStream stream.
"""
type StreamMessage {
  "Sequence number of the message in the stream"
  sequence: Int!

  "Subject the message was published to"
  subject: String!

  "Message payload as UTF-8 string"
  data: String!

  "Timestamp when the message was stored, in RFC3339 format"
  published: String!
}

"""
Result of publishing a message to NATS.
"""
type PublishResult {
  "Stream that accepted the message"
  stream: String!

  "Sequence number assigned to the message in the stream"
  sequence: Int!
}

"""
NATS JetStream consumer information.
Represents metadata about a consumer including its configuration and current runtime state.
"""
type ConsumerInfo {
  "Name of the stream the consumer is bound to"
  stream: String!

  "Unique name of the consumer"
  name: String!

  "Consumer creation timestamp in RFC3339 format"
  created: String!

  "Optional human-readable description"
  description: String

  "Durable name (if set). Durable consumers survive client disconnections"
  durableName: String

  "Single subject filter (exclusive with filterSubjects)"
  filterSubject: String

  "Multiple subject filters (exclusive with filterSubject)"
  filterSubjects: [String!]

  "Message delivery policy: all, last, new, by_start_sequence, by_start_time, last_per_subject"
  deliverPolicy: String!

  "Acknowledgement policy: explicit, all, none"
  ackPolicy: String!

  "Time in nanoseconds the server waits for an ack before redelivery"
  ackWait: Int!

  "Maximum number of delivery attempts per message. -1 means unlimited"
  maxDeliver: Int!

  "Maximum number of outstanding unacknowledged messages. -1 means unlimited"
  maxAckPending: Int!

  "Number of replicas for the consumer state"
  replicas: Int!

  "Number of messages delivered but not yet acknowledged"
  numAckPending: Int!

  "Number of messages that have been redelivered and not yet acknowledged"
  numRedelivered: Int!

  "Number of active pull requests waiting (pull consumers only)"
  numWaiting: Int!

  "Number of messages matching filter but not yet delivered"
  numPending: Int!

  "Whether the consumer is currently paused"
  paused: Boolean!

  "Time remaining until the consumer unpauses, in nanoseconds. Null if not paused"
  pauseRemaining: Int
}

type Query {
  "List all Key-Value stores in NATS JetStream with their configuration and state"
  keyValues: [KeyValue!]!

  "List all streams in NATS JetStream with their configuration and runtime state"
  streams: [StreamInfo!]!

  "List all keys in a specific KV bucket"
  kvKeys(bucket: String!): [String!]!

  "Get value for a specific key from a KV bucket. Returns null if key does not exist"
  kvGet(bucket: String!, key: String!): KVEntry

  """
  Read messages from a stream with flexible filtering. Max 100 messages per request.
  Returns messages in chronological order (oldest first).

  Filters can be combined:
  - last: max messages to return (default 10, cap 100)
  - startSeq: start reading from this sequence number (inclusive)
  - startTime: start reading from this timestamp (RFC3339, inclusive)
  - endTime: stop reading at this timestamp (RFC3339, inclusive)
  - subject: filter messages by subject (e.g. "orders.new" or "orders.*")
  """
  streamMessages(
    stream: String!
    last: Int! = 10
    startSeq: Int
    startTime: String
    endTime: String
    subject: String
  ): [StreamMessage!]!

  "List all consumers on a stream"
  consumers(stream: String!): [ConsumerInfo!]!

  "Get info about a specific consumer. Returns null if not found"
  consumerInfo(stream: String!, name: String!): ConsumerInfo
}

type Mutation {
  """
  Create a new KV bucket. Returns the created bucket info.
  - history: max history entries per key (default 1)
  - ttl: key expiration in seconds (default 0 = no expiry)
  - storage: "file" or "memory" (default "file")
  """
  kvCreate(bucket: String!, history: Int, ttl: Int, storage: String): KeyValue!

  "Put a value into a KV bucket. Creates or updates the key. Returns the stored entry"
  kvPut(bucket: String!, key: String!, value: String!): KVEntry!

  "Delete a key from a KV bucket (leaves tombstone marker). Returns true if successful"
  kvDelete(bucket: String!, key: String!): Boolean!

  "Purge a key — fully removes the key and all its history (no tombstone). Returns true if successful"
  kvPurge(bucket: String!, key: String!): Boolean!

  "Delete an entire KV bucket. Returns true if successful"
  kvDeleteBucket(bucket: String!): Boolean!

  """
  Create a new stream. Returns the created stream info.
  - subjects: subject filters (e.g. ["orders.>"])
  - retention: "limits" (default), "interest", or "workqueue"
  - storage: "file" (default) or "memory"
  - maxMsgs: max messages (-1 = unlimited, default)
  - maxBytes: max total bytes (-1 = unlimited, default)
  - maxAge: max message age in seconds (0 = no limit, default)
  - replicas: number of replicas (default 1)
  """
  streamCreate(
    name: String!
    subjects: [String!]!
    retention: String
    storage: String
    maxMsgs: Int
    maxBytes: Int
    maxAge: Int
    replicas: Int
  ): StreamInfo!

  "Delete a stream. Returns true if successful"
  streamDelete(name: String!): Boolean!

  """
  Create a new stream that aggregates (sources) messages from one or more existing streams.
  Messages from all source streams are interleaved into the new stream.
  Optionally, the stream can also listen on its own subjects.
  - sources: list of source streams to aggregate from
  - subjects: optional own subjects (e.g. ["local.>"])
  - retention, storage, maxMsgs, maxBytes, maxAge, replicas: same as streamCreate
  """
  streamCopy(
    name: String!
    sources: [StreamSourceInput!]!
    subjects: [String!]
    retention: String
    storage: String
    maxMsgs: Int
    maxBytes: Int
    maxAge: Int
    replicas: Int
  ): StreamInfo!

  "Publish a message to a NATS subject. Max payload size: 1MB. Returns the stream and sequence of the published message"
  publish(subject: String!, data: String!): PublishResult!

  """
  Schedule a message for delayed publishing. Returns immediately.
  The message will be published after the specified delay (in seconds).
  Note: scheduled messages are lost if the server restarts before delivery.
  """
  publishScheduled(subject: String!, data: String!, delay: Int!): Boolean!

  """
  Create or update a durable pull consumer on a stream.
  - name: consumer name (required)
  - filterSubject: single subject filter
  - filterSubjects: multiple subject filters (exclusive with filterSubject)
  - deliverPolicy: "all" (default), "last", "new", "last_per_subject"
  - ackPolicy: "explicit" (default), "all", "none"
  - ackWait: ack timeout in seconds (default 30)
  - maxDeliver: max delivery attempts (-1 = unlimited, default)
  - maxAckPending: max unacked messages (default 1000, -1 = unlimited)
  - replicas: number of replicas (default: inherits from stream)
  - description: optional description
  """
  consumerCreate(
    stream: String!
    name: String!
    filterSubject: String
    filterSubjects: [String!]
    deliverPolicy: String
    ackPolicy: String
    ackWait: Int
    maxDeliver: Int
    maxAckPending: Int
    replicas: Int
    description: String
  ): ConsumerInfo!

  "Delete a consumer. Returns true if successful"
  consumerDelete(stream: String!, name: String!): Boolean!

  """
  Pause a consumer until the specified time (RFC3339 format).
  The consumer will stop delivering messages until the pause expires.
  """
  consumerPause(stream: String!, name: String!, pauseUntil: String!): Boolean!

  "Resume a paused consumer immediately"
  consumerResume(stream: String!, name: String!): Boolean!
}

"""
Input for specifying a source stream to aggregate from.
"""
input StreamSourceInput {
  "Name of the source stream"
  name: String!

  "Optional subject filter — only messages matching this subject will be sourced"
  filterSubject: String
}

type Subscription {
  """
  Subscribe to new messages on a stream in real-time via WebSocket.
  Optionally filter by subject pattern (e.g. "orders.>" or "orders.new").
  """
  streamSubscribe(stream: String!, subject: String): StreamMessage!
}
