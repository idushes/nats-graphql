// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

// NATS JetStream consumer information.
// Represents metadata about a consumer including its configuration and current runtime state.
type ConsumerInfo struct {
	// Name of the stream the consumer is bound to
	Stream string `json:"stream"`
	// Unique name of the consumer
	Name string `json:"name"`
	// Consumer creation timestamp in RFC3339 format
	Created string `json:"created"`
	// Optional human-readable description
	Description *string `json:"description,omitempty"`
	// Durable name (if set). Durable consumers survive client disconnections
	DurableName *string `json:"durableName,omitempty"`
	// Single subject filter (exclusive with filterSubjects)
	FilterSubject *string `json:"filterSubject,omitempty"`
	// Multiple subject filters (exclusive with filterSubject)
	FilterSubjects []string `json:"filterSubjects,omitempty"`
	// Message delivery policy: all, last, new, by_start_sequence, by_start_time, last_per_subject
	DeliverPolicy string `json:"deliverPolicy"`
	// Acknowledgement policy: explicit, all, none
	AckPolicy string `json:"ackPolicy"`
	// Time in nanoseconds the server waits for an ack before redelivery
	AckWait int `json:"ackWait"`
	// Maximum number of delivery attempts per message. -1 means unlimited
	MaxDeliver int `json:"maxDeliver"`
	// Maximum number of outstanding unacknowledged messages. -1 means unlimited
	MaxAckPending int `json:"maxAckPending"`
	// Number of replicas for the consumer state
	Replicas int `json:"replicas"`
	// Number of messages delivered but not yet acknowledged
	NumAckPending int `json:"numAckPending"`
	// Number of messages that have been redelivered and not yet acknowledged
	NumRedelivered int `json:"numRedelivered"`
	// Number of active pull requests waiting (pull consumers only)
	NumWaiting int `json:"numWaiting"`
	// Number of messages matching filter but not yet delivered
	NumPending int `json:"numPending"`
	// Whether the consumer is currently paused
	Paused bool `json:"paused"`
	// Time remaining until the consumer unpauses, in nanoseconds. Null if not paused
	PauseRemaining *int `json:"pauseRemaining,omitempty"`
}

// Single header entry from a NATS message.
// A header key can have multiple values (like HTTP headers).
type HeaderEntry struct {
	// Header key name
	Key string `json:"key"`
	// Header values (one key can have multiple values)
	Values []string `json:"values"`
}

// Single key-value entry from a KV bucket.
type KVEntry struct {
	// Key name
	Key string `json:"key"`
	// Value stored under this key (as UTF-8 string)
	Value string `json:"value"`
	// Revision number (monotonically increasing version)
	Revision int `json:"revision"`
	// Timestamp when this revision was created, in RFC3339 format
	Created string `json:"created"`
}

// NATS JetStream Key-Value store information.
// Represents metadata about a KV bucket including its configuration and current state.
type KeyValue struct {
	// Name of the KV bucket
	Bucket string `json:"bucket"`
	// Maximum number of history entries per key (how many past values are retained)
	History int `json:"history"`
	// Time-to-live for keys in seconds. 0 means keys do not expire
	TTL int `json:"ttl"`
	// Storage backend type (e.g. JetStream)
	Storage string `json:"storage"`
	// Total size of the KV store in bytes
	Bytes int `json:"bytes"`
	// Total number of key-value pairs in the store
	Values int `json:"values"`
	// Whether the KV store data is compressed
	IsCompressed bool `json:"isCompressed"`
}

type Mutation struct {
}

// Result of publishing a message to NATS.
type PublishResult struct {
	// Stream that accepted the message
	Stream string `json:"stream"`
	// Sequence number assigned to the message in the stream
	Sequence int `json:"sequence"`
}

type Query struct {
}

// NATS JetStream stream information.
// Represents metadata about a stream including its configuration and current runtime state.
type StreamInfo struct {
	// Unique name of the stream
	Name string `json:"name"`
	// List of subject filters the stream is listening on (e.g. ['orders.>', 'payments.*'])
	Subjects []string `json:"subjects"`
	// Message retention policy: Limits (by count/size/age), Interest (while consumers exist), or WorkQueue (ack-based removal)
	Retention string `json:"retention"`
	// Maximum number of consumers allowed on this stream. -1 means unlimited
	MaxConsumers int `json:"maxConsumers"`
	// Maximum number of messages stored in the stream. -1 means unlimited
	MaxMsgs int `json:"maxMsgs"`
	// Maximum total size of messages in the stream in bytes. -1 means unlimited
	MaxBytes int `json:"maxBytes"`
	// Maximum age of messages in the stream in seconds. 0 means no age limit
	MaxAge int `json:"maxAge"`
	// Storage type: File (persistent to disk) or Memory (in-memory only)
	Storage string `json:"storage"`
	// Number of stream replicas for high availability in a NATS cluster
	Replicas int `json:"replicas"`
	// Current number of messages stored in the stream
	Messages int `json:"messages"`
	// Current total size of all messages in the stream in bytes
	Bytes int `json:"bytes"`
	// Current number of active consumers subscribed to this stream
	Consumers int `json:"consumers"`
	// Stream creation timestamp in RFC3339 format
	Created string `json:"created"`
	// List of source streams this stream is aggregating from. Null if not sourcing
	Sources []*StreamSourceInfo `json:"sources,omitempty"`
}

// Single message from a NATS JetStream stream.
type StreamMessage struct {
	// Sequence number of the message in the stream
	Sequence int `json:"sequence"`
	// Subject the message was published to
	Subject string `json:"subject"`
	// Message payload as UTF-8 string
	Data string `json:"data"`
	// Timestamp when the message was stored, in RFC3339 format
	Published string `json:"published"`
	// Message headers (key-value pairs). Null if no headers were set
	Headers []*HeaderEntry `json:"headers,omitempty"`
}

// Information about an upstream source stream.
type StreamSourceInfo struct {
	// Name of the source stream
	Name string `json:"name"`
	// Number of messages behind the source stream
	Lag int `json:"lag"`
	// Duration since last activity in nanoseconds. -1 means no activity
	Active int `json:"active"`
	// Subject filter applied to this source, if any
	FilterSubject *string `json:"filterSubject,omitempty"`
}

// Input for specifying a source stream to aggregate from.
type StreamSourceInput struct {
	// Name of the source stream
	Name string `json:"name"`
	// Optional subject filter â€” only messages matching this subject will be sourced
	FilterSubject *string `json:"filterSubject,omitempty"`
}

type Subscription struct {
}
