package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"nats-graphql/graph/model"
	"time"

	"github.com/nats-io/nats.go/jetstream"
)

// KvPut is the resolver for the kvPut field.
func (r *mutationResolver) KvPut(ctx context.Context, bucket string, key string, value string) (*model.KVEntry, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return nil, err
	}

	rev, err := kv.Put(ctx, key, []byte(value))
	if err != nil {
		return nil, err
	}

	// Fetch the entry back to get the full metadata
	entry, err := kv.GetRevision(ctx, key, rev)
	if err != nil {
		return nil, err
	}

	return &model.KVEntry{
		Key:      entry.Key(),
		Value:    string(entry.Value()),
		Revision: int(entry.Revision()),
		Created:  entry.Created().Format(time.RFC3339),
	}, nil
}

// KvDelete is the resolver for the kvDelete field.
func (r *mutationResolver) KvDelete(ctx context.Context, bucket string, key string) (bool, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return false, err
	}

	if err := kv.Delete(ctx, key); err != nil {
		return false, err
	}

	return true, nil
}

// KeyValues is the resolver for the keyValues field.
func (r *queryResolver) KeyValues(ctx context.Context) ([]*model.KeyValue, error) {
	var result []*model.KeyValue

	names := r.JS.KeyValueStoreNames(ctx)
	for name := range names.Name() {
		kv, err := r.JS.KeyValue(ctx, name)
		if err != nil {
			return nil, err
		}

		status, err := kv.Status(ctx)
		if err != nil {
			return nil, err
		}

		ttlSeconds := 0
		if status.TTL() > 0 {
			ttlSeconds = int(status.TTL() / time.Second)
		}

		result = append(result, &model.KeyValue{
			Bucket:       status.Bucket(),
			History:      int(status.History()),
			TTL:          ttlSeconds,
			Storage:      status.BackingStore(),
			Bytes:        int(status.Bytes()),
			Values:       int(status.Values()),
			IsCompressed: status.IsCompressed(),
		})
	}

	if err := names.Error(); err != nil {
		return nil, err
	}

	return result, nil
}

// Streams is the resolver for the streams field.
func (r *queryResolver) Streams(ctx context.Context) ([]*model.StreamInfo, error) {
	var result []*model.StreamInfo

	streams := r.JS.ListStreams(ctx)
	for si := range streams.Info() {
		subjects := make([]string, 0, len(si.Config.Subjects))
		subjects = append(subjects, si.Config.Subjects...)

		result = append(result, &model.StreamInfo{
			Name:         si.Config.Name,
			Subjects:     subjects,
			Retention:    si.Config.Retention.String(),
			MaxConsumers: si.Config.MaxConsumers,
			MaxMsgs:      int(si.Config.MaxMsgs),
			MaxBytes:     int(si.Config.MaxBytes),
			Storage:      si.Config.Storage.String(),
			Replicas:     si.Config.Replicas,
			Messages:     int(si.State.Msgs),
			Bytes:        int(si.State.Bytes),
			Consumers:    si.State.Consumers,
			Created:      si.Created.Format(time.RFC3339),
		})
	}

	if err := streams.Err(); err != nil {
		return nil, err
	}

	return result, nil
}

// KvKeys is the resolver for the kvKeys field.
func (r *queryResolver) KvKeys(ctx context.Context, bucket string) ([]string, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return nil, err
	}

	lister, err := kv.ListKeys(ctx)
	if err != nil {
		return nil, err
	}

	var keys []string
	for key := range lister.Keys() {
		keys = append(keys, key)
	}

	return keys, nil
}

// KvGet is the resolver for the kvGet field.
func (r *queryResolver) KvGet(ctx context.Context, bucket string, key string) (*model.KVEntry, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return nil, err
	}

	entry, err := kv.Get(ctx, key)
	if err != nil {
		if errors.Is(err, jetstream.ErrKeyNotFound) {
			return nil, nil
		}
		return nil, err
	}

	return &model.KVEntry{
		Key:      entry.Key(),
		Value:    string(entry.Value()),
		Revision: int(entry.Revision()),
		Created:  entry.Created().Format(time.RFC3339),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
