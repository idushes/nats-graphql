package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"nats-graphql/graph/model"
	"time"
)

// KeyValues is the resolver for the keyValues field.
func (r *queryResolver) KeyValues(ctx context.Context) ([]*model.KeyValue, error) {
	var result []*model.KeyValue

	names := r.JS.KeyValueStoreNames(ctx)
	for name := range names.Name() {
		kv, err := r.JS.KeyValue(ctx, name)
		if err != nil {
			return nil, err
		}

		status, err := kv.Status(ctx)
		if err != nil {
			return nil, err
		}

		ttlSeconds := 0
		if status.TTL() > 0 {
			ttlSeconds = int(status.TTL() / time.Second)
		}

		result = append(result, &model.KeyValue{
			Bucket:       status.Bucket(),
			History:      int(status.History()),
			TTL:          ttlSeconds,
			Storage:      status.BackingStore(),
			Bytes:        int(status.Bytes()),
			Values:       int(status.Values()),
			IsCompressed: status.IsCompressed(),
		})
	}

	if err := names.Error(); err != nil {
		return nil, err
	}

	return result, nil
}

// Streams is the resolver for the streams field.
func (r *queryResolver) Streams(ctx context.Context) ([]*model.StreamInfo, error) {
	var result []*model.StreamInfo

	streams := r.JS.ListStreams(ctx)
	for si := range streams.Info() {
		subjects := make([]string, 0, len(si.Config.Subjects))
		subjects = append(subjects, si.Config.Subjects...)

		result = append(result, &model.StreamInfo{
			Name:         si.Config.Name,
			Subjects:     subjects,
			Retention:    si.Config.Retention.String(),
			MaxConsumers: si.Config.MaxConsumers,
			MaxMsgs:      int(si.Config.MaxMsgs),
			MaxBytes:     int(si.Config.MaxBytes),
			Storage:      si.Config.Storage.String(),
			Replicas:     si.Config.Replicas,
			Messages:     int(si.State.Msgs),
			Bytes:        int(si.State.Bytes),
			Consumers:    si.State.Consumers,
			Created:      si.Created.Format(time.RFC3339),
		})
	}

	if err := streams.Err(); err != nil {
		return nil, err
	}

	return result, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
