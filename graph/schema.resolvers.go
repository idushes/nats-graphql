package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"nats-graphql/graph/model"
	"time"

	"github.com/nats-io/nats.go/jetstream"
)

// KvPut is the resolver for the kvPut field.
func (r *mutationResolver) KvPut(ctx context.Context, bucket string, key string, value string) (*model.KVEntry, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return nil, err
	}

	rev, err := kv.Put(ctx, key, []byte(value))
	if err != nil {
		return nil, err
	}

	// Fetch the entry back to get the full metadata
	entry, err := kv.GetRevision(ctx, key, rev)
	if err != nil {
		return nil, err
	}

	return &model.KVEntry{
		Key:      entry.Key(),
		Value:    string(entry.Value()),
		Revision: int(entry.Revision()),
		Created:  entry.Created().Format(time.RFC3339),
	}, nil
}

// KvDelete is the resolver for the kvDelete field.
func (r *mutationResolver) KvDelete(ctx context.Context, bucket string, key string) (bool, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return false, err
	}

	if err := kv.Delete(ctx, key); err != nil {
		return false, err
	}

	return true, nil
}

// Publish is the resolver for the publish field.
func (r *mutationResolver) Publish(ctx context.Context, subject string, data string) (*model.PublishResult, error) {
	const maxPayload = 1 << 20 // 1 MB
	if len(data) > maxPayload {
		return nil, fmt.Errorf("payload too large: %d bytes (max %d)", len(data), maxPayload)
	}

	ack, err := r.JS.Publish(ctx, subject, []byte(data))
	if err != nil {
		return nil, err
	}

	return &model.PublishResult{
		Stream:   ack.Stream,
		Sequence: int(ack.Sequence),
	}, nil
}

// KeyValues is the resolver for the keyValues field.
func (r *queryResolver) KeyValues(ctx context.Context) ([]*model.KeyValue, error) {
	var result []*model.KeyValue

	names := r.JS.KeyValueStoreNames(ctx)
	for name := range names.Name() {
		kv, err := r.JS.KeyValue(ctx, name)
		if err != nil {
			return nil, err
		}

		status, err := kv.Status(ctx)
		if err != nil {
			return nil, err
		}

		ttlSeconds := 0
		if status.TTL() > 0 {
			ttlSeconds = int(status.TTL() / time.Second)
		}

		result = append(result, &model.KeyValue{
			Bucket:       status.Bucket(),
			History:      int(status.History()),
			TTL:          ttlSeconds,
			Storage:      status.BackingStore(),
			Bytes:        int(status.Bytes()),
			Values:       int(status.Values()),
			IsCompressed: status.IsCompressed(),
		})
	}

	if err := names.Error(); err != nil {
		return nil, err
	}

	return result, nil
}

// Streams is the resolver for the streams field.
func (r *queryResolver) Streams(ctx context.Context) ([]*model.StreamInfo, error) {
	var result []*model.StreamInfo

	streams := r.JS.ListStreams(ctx)
	for si := range streams.Info() {
		subjects := make([]string, 0, len(si.Config.Subjects))
		subjects = append(subjects, si.Config.Subjects...)

		result = append(result, &model.StreamInfo{
			Name:         si.Config.Name,
			Subjects:     subjects,
			Retention:    si.Config.Retention.String(),
			MaxConsumers: si.Config.MaxConsumers,
			MaxMsgs:      int(si.Config.MaxMsgs),
			MaxBytes:     int(si.Config.MaxBytes),
			Storage:      si.Config.Storage.String(),
			Replicas:     si.Config.Replicas,
			Messages:     int(si.State.Msgs),
			Bytes:        int(si.State.Bytes),
			Consumers:    si.State.Consumers,
			Created:      si.Created.Format(time.RFC3339),
		})
	}

	if err := streams.Err(); err != nil {
		return nil, err
	}

	return result, nil
}

// KvKeys is the resolver for the kvKeys field.
func (r *queryResolver) KvKeys(ctx context.Context, bucket string) ([]string, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return nil, err
	}

	lister, err := kv.ListKeys(ctx)
	if err != nil {
		return nil, err
	}

	var keys []string
	for key := range lister.Keys() {
		keys = append(keys, key)
	}

	return keys, nil
}

// KvGet is the resolver for the kvGet field.
func (r *queryResolver) KvGet(ctx context.Context, bucket string, key string) (*model.KVEntry, error) {
	kv, err := r.JS.KeyValue(ctx, bucket)
	if err != nil {
		return nil, err
	}

	entry, err := kv.Get(ctx, key)
	if err != nil {
		if errors.Is(err, jetstream.ErrKeyNotFound) {
			return nil, nil
		}
		return nil, err
	}

	return &model.KVEntry{
		Key:      entry.Key(),
		Value:    string(entry.Value()),
		Revision: int(entry.Revision()),
		Created:  entry.Created().Format(time.RFC3339),
	}, nil
}

// StreamMessages is the resolver for the streamMessages field.
func (r *queryResolver) StreamMessages(ctx context.Context, stream string, last int) ([]*model.StreamMessage, error) {
	const maxMessages = 100
	if last <= 0 {
		return nil, fmt.Errorf("last must be > 0")
	}
	if last > maxMessages {
		return nil, fmt.Errorf("last exceeds maximum of %d messages", maxMessages)
	}

	s, err := r.JS.Stream(ctx, stream)
	if err != nil {
		return nil, err
	}

	info, err := s.Info(ctx)
	if err != nil {
		return nil, err
	}

	if info.State.Msgs == 0 {
		return []*model.StreamMessage{}, nil
	}

	// Calculate the starting sequence
	lastSeq := info.State.LastSeq
	firstSeq := info.State.FirstSeq

	startSeq := lastSeq - uint64(last) + 1
	if startSeq < firstSeq || startSeq > lastSeq {
		startSeq = firstSeq
	}

	var result []*model.StreamMessage
	for seq := startSeq; seq <= lastSeq; seq++ {
		msg, err := s.GetMsg(ctx, seq)
		if err != nil {
			// Skip deleted/purged messages
			continue
		}

		result = append(result, &model.StreamMessage{
			Sequence:  int(msg.Sequence),
			Subject:   msg.Subject,
			Data:      string(msg.Data),
			Published: msg.Time.Format(time.RFC3339),
		})
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
